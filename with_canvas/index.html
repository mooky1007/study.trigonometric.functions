<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html,
    body {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #000;
      overflow: hidden;
    }

    canvas {
      position: absolute;
      width: 100%;
      aspect-ratio: 1/1;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    @media screen and (max-width: 768px) {
      canvas {
        width: 100vmax;
        top: 0;
        transform: translateX(-50%);
      }
    }
  </style>
</head>

<body>
  <canvas id="canvas2"></canvas>
  <canvas id="canvas"></canvas>

  <script>
    let time = 0;

    const canvas = document.querySelector('#canvas');
    const canvas2 = document.querySelector('#canvas2');
    const ctx = canvas.getContext("2d");
    const ctx2 = canvas2.getContext("2d");

    const lastPos = {}

    canvas.width = 2400;
    canvas.height = 2400;
    canvas2.width = 2400;
    canvas2.height = 2400;

    ctx2.fillStyle = '#000';
    ctx2.fillRect(0, 0, canvas2.width, canvas2.height);

    // const drawLine = () => {
    //   ctx.font = '14px sans-serif';

    //   ctx.beginPath();
    //   ctx.strokeStyle = '#eee';
    //   for (let i = 0; i <= canvas.width; i += 10) {
    //     ctx.moveTo(i, 0);
    //     ctx.lineTo(i, canvas.width);
    //     ctx.moveTo(0, i);
    //     ctx.lineTo(canvas.width, i);
    //   }
    //   ctx.stroke();

    //   ctx.save();
    //   ctx.strokeStyle = '#ff0000aa';
    //   ctx.beginPath();
    //   ctx.moveTo(canvas.width / 2, 0);
    //   ctx.lineTo(canvas.width / 2, canvas.width);
    //   ctx.moveTo(0, canvas.width / 2);
    //   ctx.lineTo(canvas.width, canvas.width / 2);
    //   ctx.stroke();
    //   ctx.restore();

    //   ctx.beginPath();
    //   ctx.arc(canvas.width / 2, canvas.width / 2, 3, 0, Math.PI * 2);
    //   ctx.fill();

    //   ctx.textBaseline = 'top';
    //   const text = ctx.measureText(`${canvas.width/2}, ${canvas.width/2}`)
    //   const width = text.width;
    //   const height = text.actualBoundingBoxAscent + text.actualBoundingBoxDescent;
    //   ctx.fillText(`${canvas.width/2}, ${canvas.width/2}`, canvas.width / 2 - width / 2, canvas.width / 2 + 5);
    // }

    const drawLine = () => {
      // ctx.beginPath();
      // ctx.strokeStyle = '#eeeeee22';
      // for (let i = 0; i <= canvas.width; i += 10) {
      //   ctx.moveTo(i, 0);
      //   ctx.lineTo(i, canvas.width);
      //   ctx.moveTo(0, i);
      //   ctx.lineTo(canvas.width, i);
      // }
      // ctx.stroke();

      ctx.save()
      ctx.beginPath();
      ctx.shadowBlur = 10;
      ctx.shadowColor = "rgba(0,0,0,0.7)";
      ctx.arc(canvas.width / 2, canvas.width / 2, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore()

      ctx.save()
      ctx.beginPath();
      ctx.filter = 'blur(3px)';
      ctx.fillStyle = '#ffffff11'
      ctx.arc(canvas.width / 2, canvas.width / 2, 18, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore()

      ctx.save()
      ctx.beginPath();
      ctx.filter = 'blur(6px)';
      ctx.fillStyle = '#ffffff11'
      ctx.arc(canvas.width / 2, canvas.width / 2, 32, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore()

      ctx.save()
      ctx.beginPath();
      ctx.filter = 'blur(12px)';
      ctx.fillStyle = '#ffffff11'
      ctx.arc(canvas.width / 2, canvas.width / 2, 64, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore()
    }


    const drawOrbit = (r) => {
      ctx.beginPath();
      ctx.strokeStyle = '#dddddd11';
      ctx.arc(canvas.width / 2, canvas.height / 2, r, 0, Math.PI * 2);
      ctx.stroke();
    };

    const rotateCircle = (r, r2 = 3, speed = 1) => {
      drawOrbit(r);
      ctx.fillStyle = '#fff'
      ctx.beginPath();
      const defaultSpeed = (1 / (Math.sqrt(r ** 3)));
      speed *= 1000;
      const x = Math.sin((time * defaultSpeed * speed * Math.PI / 180 + (Math.PI / 1.5 + Math.sqrt(r ** 3)))) * r + canvas.width / 2;
      const y = Math.cos((time * defaultSpeed * speed * Math.PI / 180) + (Math.PI / 1.5 + Math.sqrt(r ** 3))) * r + canvas.width / 2;
      ctx.arc(x, y, r2, 0, Math.PI * 2);
      ctx.fill();

      // ctx.font = '14px sans-serif';
      // ctx.fillStyle = '#ffffffaa';
      // ctx.textBaseline = 'top';
      // const text = ctx.measureText(`${r}`)
      // const width = text.width;
      // const height = text.actualBoundingBoxAscent + text.actualBoundingBoxDescent;
      // ctx.fillText(`${r}`, x - width / 2, y + 10);
    }

    const rotateCircle2 = (r, r2 = 1, speed = 1) => {
      ctx2.save()
      const defaultSpeed = (1 / (Math.sqrt(r ** 3)));
      speed *= 1000;
      const x = Math.sin((time * defaultSpeed * speed * Math.PI / 180) + (Math.PI / 1.5 + Math.sqrt(r ** 3))) * r + canvas.width / 2;
      const y = Math.cos((time * defaultSpeed * speed * Math.PI / 180) + (Math.PI / 1.5 + Math.sqrt(r ** 3))) * r + canvas.width / 2;
      if (lastPos[r]) {
        ctx2.strokeStyle = '#ffd480aa';
        ctx2.lineWidth = r2;
        ctx2.beginPath();
        ctx2.moveTo(lastPos[r].x, lastPos[r].y);
        ctx2.lineTo(x, y);
        ctx2.stroke();
      }
      ctx2.restore()

      lastPos[r] = {
        x,
        y
      };
    }

    const draw = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx2.save()
      ctx2.fillStyle = 'rgba(0, 0, 0, 0.03)';
      ctx2.fillRect(0, 0, canvas2.width, canvas2.height);
      ctx2.restore()

      drawLine();

      for (let i = 0; i <= 1500; i += 20) {
        rotateCircle(i);
        rotateCircle2(i);
      };

      time += 1;
      requestAnimationFrame(draw);
    };

    requestAnimationFrame(draw);
  </script>
</body>

</html>